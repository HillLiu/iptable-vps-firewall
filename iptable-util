#!/bin/bash

dump ()
{
    echo ""
    echo "###"
    echo "# $1"
    echo "###"
    echo ""
}

usage()
{
  echo -n "
iptable-util -e eth0 -o \"80 443\" -t \"1.1.1.1 2.2.2.2\"

Use this script careful, it possible deny all your connections.
More sample usage. https://github.com/HillLiu/iptable-vps-firewall/wiki/sample

 Options:
  -h, --help                  Display this help and exit.
  -e, --external-interface    External Network.
  -i, --internal-interface    Internal Network.
  -o, --open-port             Open Port.
  -t, --trust                 Trust host.
  -c, --cmd                   Iptable command path.
  -l, --list                  Current rule list.
  -d, --debug                 Reset after 60sec.
      --debug-sec             Reset after \$n sec.
      --docker-port           Docker Port
      --stop                  Reset all rule.
      --show                  Display information only.
"
}

netinfo ()
{
    IP=""
    MASK=""
    NET=""

    for NIC in "$@" ; do
        {
        IP=`ifconfig $NIC |grep -P -m1 'inet addr|inet' |awk '{print $2}'|sed -e "s/addr\://"`
        MASK=`ifconfig $NIC |grep -P -m1 'inet addr|inet' |awk '{print $4}'|sed -e "s/Mask\://"`
        IP1=`echo $IP |awk -F'.' '{print $1}'`
        if [ "$IP1" = "" ]; then
            echo ""
            echo "Warning: there is no IP found on $NIC."
            echo "Action is aborted."
            echo "Please make sure the interface is setup properly, then try again."
            echo ""
            exit 1
        else
        IP2=`echo $IP |awk -F'.' '{print $2}'`
        IP3=`echo $IP |awk -F'.' '{print $3}'`
        IP4=`echo $IP |awk -F'.' '{print $4}'`
        MASK1=`echo $MASK |awk -F'.' '{print $1}'`
        MASK2=`echo $MASK |awk -F'.' '{print $2}'`
        MASK3=`echo $MASK |awk -F'.' '{print $3}'`
        MASK4=`echo $MASK |awk -F'.' '{print $4}'`
        let NET1="$IP1 & $MASK1"
        let NET2="$IP2 & $MASK2"
        let NET3="$IP3 & $MASK3"
        let NET4="$IP4 & $MASK4"
        NET="$NET1.$NET2.$NET3.$NET4"
        fi
        }
    done
}


while [[ $# -gt 0 ]];  do
    key="$1"
    case $key in
        -h|--help)
        usage
        exit;
	;;
	-e|--external-interface)
	EXT_IF="$2"
	shift # past argument
	;;
	-i|--internal-interface)
	INT_IF="$2"
	shift # past argument
	;;
	-o|--open-port)
	OPEN_PORT="$2"
	shift # past argument
	;;
	-t|--trust)
	ALLOW_HOSTS="$2"
	shift # past argument
	;;
	-c|--cmd)
	IPCMD="$2"
	shift # past argument
	;;
	-l|--list)
        LIST_RULES_ONLY=on
	;;
	-d|--debug)
        DEBUG_ONLY=on
	;;
	--debug-sec)
        DEBUG_ONLY=on
        DEBUG_SEC=$2
	shift # past argument
	;;
	--nat)
        NAT_FROM_IP="$2"
        NAT_FROM_PORT="$3"
        NAT_TO_IP="$4"
        NAT_TO_PORT="$5"
	shift # past argument
	shift # past argument
	shift # past argument
	shift # past argument
	;;
        --docker-port)
        DOCKER_OPEN_PORT="$2"
	shift # past argument
        ;;
	--show)
        SHOW_INFO_ONLY=on
	;;
	--stop)
        RESET_ONLY=on
	;;
	*)
        # unknown option
	;;
    esac
    shift # past argument or value
done

if [ "$(whoami)" != "root" ]; then
    dump "Sorry, you are not root."
    exit 1
fi

## Check if iptalbe exists 
if [ -z "$IPCMD" ] ; then
    IPCMD="iptables";
fi
CHK_IPTABLES=$(which $IPCMD 2>/dev/null)
if [ -z "$CHK_IPTABLES" ]; then
    dump "$(basename $0): iptables program is not found."
    exit 1
fi

if [ -n "$LIST_RULES_ONLY" ] ; then
    dump "Rule List"
    $IPCMD -L -n
    echo ""
    dump "Nat Rule List"
    $IPCMD -t nat -L
    echo ""
    dump "Command List"
    $IPCMD -S
    echo ""
    exit 1;
fi

initialize ()
{
    $IPCMD -P INPUT   ACCEPT
    $IPCMD -P OUTPUT  ACCEPT
    $IPCMD -P FORWARD ACCEPT
    $IPCMD -F
    $IPCMD -X
    $IPCMD -Z
}

initNAT ()
{
  echo ""
  echo "## NAT From IP ##"
  echo $NAT_FROM_IP
  echo "## NAT From Port ##"
  echo $NAT_FROM_PORT
  echo "## NAT To IP ##"
  echo $NAT_TO_IP
  echo "## NAT To Port ##"
  echo $NAT_TO_PORT
  echo ""
  $IPCMD -A INPUT -p icmp --icmp-type 8 -s 0/0 -d $NAT_FROM_IP -m state --state NEW,ESTABLISHED,RELATED -j PING_OF_DEATH
  $IPCMD -A PREROUTING -t nat -p tcp --source $NAT_FROM_IP --dport $NAT_FROM_PORT -j DNAT --to $NAT_TO_IP:$NAT_TO_PORT
}

if [ -n "$RESET_ONLY" ] ; then
    echo "# Reset only"
    initialize
    $IPCMD -S
    exit;
fi

if [ -z "$EXT_IF" ] ; then
  if [ -z "$NAT_FROM_IP"] ; then 
    dump "External Interface should not be empty"
  else
    initNAT    
  fi
  exit 1
fi

if [ -z "$INT_IF" ] ; then
    INT_IF=$EXT_IF;
fi

dump "Paramters"

echo "# External Interface:"
echo $EXT_IF 
echo "" 

echo "# Internal Interface:"
echo $INT_IF 
echo "" 

if [ "${OPEN_PORT}" ] ; then
    echo "# Open Ports:"
    for port in ${OPEN_PORT[@]} ; do
        echo $port 
    done
    echo ""
fi

echo "# Iptable command-line path:"
echo $IPCMD 
echo "" 

if [ "${ALLOW_HOSTS}" ] ; then
    echo "# Trust Hosts:"
    for allow_host in ${ALLOW_HOSTS[@]} ; do
        echo $allow_host 
    done
    echo ""
fi

## default
initialize
HI="1024:65535"

## External 
netinfo "$EXT_IF"
EXT_IP="$IP"
EXT_NET="$NET"/"$MASK"

echo ""
echo "## External IP ##"
echo $EXT_IP
echo "## External Net ##"
echo $EXT_NET
echo ""

## Internal 
netinfo "$INT_IF"
INT_IP="$IP"
INT_NET="$NET"/"$MASK"

echo "## Internal IP ##"
echo $INT_IP
echo "## Internal Net ##"
echo $INT_NET
echo ""

if [ -n "$SHOW_INFO_ONLY" ] ; then
    exit;
fi

dump "Start to apply firewall... Press ctrl+c to cancel."
sleep 2;


## Default drop all
$IPCMD -P INPUT DROP
$IPCMD -P FORWARD DROP

## Allow lo
LOCAL=(lo docker0 cbr0)

for lo in ${LOCAL[@]} ; do
  $IPCMD -A INPUT -i $lo -j ACCEPT
  $IPCMD -A OUTPUT -o $lo -j ACCEPT
done

## Allow internal
if [ "$INT_IF" != "$EXT_IF" ] ; then
   $IPCMD -A INPUT -i $INT_IF -j ACCEPT
   $IPCMD -A OUTPUT -o $INT_IF -j ACCEPT
   $IPCMD -A FORWARD -i $INT_IF -j ACCEPT
   $IPCMD -A FORWARD -o $INT_IF -j ACCEPT
fi

###
# Allow trust
###
if [ "${ALLOW_HOSTS}" ] ; then
    for allow_host in ${ALLOW_HOSTS[@]} ; do
	$IPCMD -A INPUT -s $allow_host -j ACCEPT
	$IPCMD -A OUTPUT -d $allow_host -j ACCEPT
	$IPCMD -A FORWARD -s $allow_host -j ACCEPT
	$IPCMD -A FORWARD -d $allow_host -j ACCEPT
    done
fi


###
# FTP Active mode
###
modprobe ip_conntrack
modprobe ip_conntrack_ftp
$IPCMD -A OUTPUT -p tcp --sport $HI -m multiport --dports 20,$HI -m state --state ESTABLISHED -j ACCEPT
$IPCMD -A OUTPUT -p tcp -m tcp --sport $HI -m multiport --dports 21,$HI -m state --state NEW,ESTABLISHED -j ACCEPT
$IPCMD -A OUTPUT -p tcp -m tcp --sport $HI --dport $HI -m state --state NEW,RELATED -j ACCEPT
$IPCMD -A INPUT -p tcp --sport 20 --dport $HI -m state --state ESTABLISHED,RELATED -j ACCEPT
$IPCMD -A INPUT -p tcp -m tcp -m multiport --sports 21,$HI --dport $HI -m state --state ESTABLISHED -j ACCEPT

###
# Defend ping-of-death
###
$IPCMD -N PING_OF_DEATH
$IPCMD -A PING_OF_DEATH -p icmp \
         -m hashlimit \
         --hashlimit-name icmp \
         --hashlimit-mode srcip \
         --hashlimit 5/second \
         --hashlimit-burst 2 \
         -j ACCEPT 
$IPCMD -A PING_OF_DEATH -p icmp -j DROP
$IPCMD -A INPUT -p icmp --icmp-type 8 -s 0/0 -d $EXT_IP -m state --state NEW,ESTABLISHED,RELATED -j PING_OF_DEATH

###
# Defend sync flood
###
$IPCMD -N synfoold
$IPCMD -A synfoold -p tcp --syn -m limit --limit 1/s --limit-burst 100 -j RETURN
$IPCMD -A synfoold -p tcp -j REJECT --reject-with tcp-reset
$IPCMD -A INPUT -p tcp -m state --state NEW -j synfoold

###
# Defend malicious scan
###
$IPCMD -A INPUT -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP
$IPCMD -A INPUT -p tcp --tcp-flags ALL ALL -j DROP
$IPCMD -A INPUT -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP
$IPCMD -A INPUT -p tcp --tcp-flags ALL NONE -j DROP
$IPCMD -A INPUT -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
$IPCMD -A INPUT -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP
$IPCMD -A INPUT -p tcp --tcp-flags SYN,ACK,FIN,RST RST -m limit --limit 6/m -j ACCEPT

## 
# tcp_packets
##
$IPCMD -N tcp_packets
$IPCMD -A tcp_packets -p TCP --tcp-flags ALL FIN,URG,PSH -j LOG --log-prefix "been scanned:"
$IPCMD -A tcp_packets -p TCP --tcp-flags ALL ALL -j LOG --log-prefix "been scanned:"
$IPCMD -A tcp_packets -p TCP --tcp-flags ALL SYN,RST,ACK,FIN,URG -j LOG --log-prefix "been scanned:"
$IPCMD -A tcp_packets -p TCP --tcp-flags ALL NONE -j LOG --log-prefix "been scanned:"
$IPCMD -A tcp_packets -p TCP --tcp-flags SYN,RST SYN,RST -j LOG --log-prefix "been scanned:"
$IPCMD -A tcp_packets -p TCP --tcp-flags SYN,FIN SYN,FIN -j LOG --log-prefix "been scanned:"
$IPCMD -A tcp_packets -p TCP --tcp-flags ALL FIN,URG,PSH -j DROP
$IPCMD -A tcp_packets -p TCP --tcp-flags ALL ALL -j DROP
$IPCMD -A tcp_packets -p TCP --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP
$IPCMD -A tcp_packets -p TCP --tcp-flags ALL NONE -j DROP
$IPCMD -A tcp_packets -p TCP --tcp-flags SYN,RST SYN,RST -j DROP
$IPCMD -A tcp_packets -p TCP --tcp-flags SYN,FIN SYN,FIN -j DROP
$IPCMD -A FORWARD -p tcp -j tcp_packets

## Allow tcp packet for open port
$IPCMD -N allowed
$IPCMD -A allowed -p TCP --syn -j ACCEPT
$IPCMD -A allowed -p TCP -m state --state ESTABLISHED,RELATED -j ACCEPT
$IPCMD -A allowed -p TCP -j DROP
$IPCMD -A tcp_packets -p TCP -s 0/0 --dport $HI -j allowed
for allow_port in $OPEN_PORT; do
  echo "Allow Port: $allow_port"
  echo ""
  $IPCMD -A tcp_packets -p TCP -s 0/0 --dport $allow_port -j allowed
done

## 
# Restrict Docker
##

COMMON_PORT="80 443"
if [ "${DOCKER_OPEN_PORT}" ] ; then
  ALL_DOCKER_OPEN_PORT=("${DOCKER_OPEN_PORT[@]}" "${COMMON_PORT[@]}")
else
  ALL_DOCKER_OPEN_PORT=COMMON_PORT
fi

PRIVATE=(
  "10.0.0.0/8"
  "172.16.0.0/12"
  "192.168.0.0/16"
)
if [ "${ALLOW_HOSTS}" ] ; then
  trustAndPrivate=("${ALLOW_HOSTS[@]}" "${PRIVATE[@]}")
else
  trustAndPrivate=PRIVATE
fi

$IPCMD -N DOCKER-USER

for allow_port in ${ALL_DOCKER_OPEN_PORT[@]}; do
  echo "docker port: $allow_port"
  $IPCMD -A DOCKER-USER -i $EXT_IF -p tcp -m tcp --dport $allow_port -j ACCEPT 
done
echo ""

for private in ${trustAndPrivate[@]} ; do
  echo "docker trust host: $private"
  $IPCMD -A DOCKER-USER -j ACCEPT -s $private
  $IPCMD -A DOCKER-USER -j DROP -i $EXT_IF -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d $private
  $IPCMD -A DOCKER-USER -j DROP -i $EXT_IF -p udp -m udp --dport 0:32767 -d $private
done
echo ""

$IPCMD -A DOCKER-USER -j RETURN


## Drop illegal connection
$IPCMD -A INPUT -i $EXT_IF -m state --state RELATED,ESTABLISHED -j ACCEPT 
$IPCMD -A FORWARD -i $EXT_IF -m state --state NEW,INVALID -j DROP 
$IPCMD -A OUTPUT -m state --state INVALID -j DROP

###
# Enalbe internal routing
###
if [ "$INT_IF" != "$EXT_IF" ] ; then
   $IPCMD -t nat -P PREROUTING  ACCEPT
   $IPCMD -t nat -P POSTROUTING ACCEPT
   $IPCMD -t nat -A POSTROUTING -s $INT_NET -j SNAT --to-source $EXT_IP
   $IPCMD -t nat -A POSTROUTING -o $EXT_IF -s $INT_NET -j MASQUERADE
fi

## Wrap packet
$IPCMD -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
$IPCMD -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
$IPCMD -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT

## Enable OPEN_PORT
for PORT in $OPEN_PORT; do
    $IPCMD -A INPUT -i $EXT_IF -p tcp --dport $PORT -j ACCEPT
    $IPCMD -A INPUT -i $EXT_IF -p udp --dport $PORT -j ACCEPT
    $IPCMD -A INPUT -p tcp --sport $HI -d $EXT_IP --dport $PORT -j ACCEPT
    $IPCMD -A INPUT -p udp --sport $HI -d $EXT_IP --dport $PORT -j ACCEPT
    $IPCMD -A OUTPUT -o $EXT_IF -p tcp --dport $PORT -j ACCEPT
    $IPCMD -A OUTPUT -o $EXT_IF -p udp --dport $PORT -j ACCEPT
    $IPCMD -A OUTPUT -p tcp --sport $HI -d $EXT_IP --dport $PORT -j ACCEPT
    $IPCMD -A OUTPUT -p udp --sport $HI -d $EXT_IP --dport $PORT -j ACCEPT
    $IPCMD -A FORWARD -i $EXT_IF -p tcp --dport $PORT -j ACCEPT
    $IPCMD -A FORWARD -i $EXT_IF -p udp --dport $PORT -j ACCEPT
    $IPCMD -A FORWARD -p tcp --sport $HI -d $EXT_IP --dport $PORT -j ACCEPT
    $IPCMD -A FORWARD -p udp --sport $HI -d $EXT_IP --dport $PORT -j ACCEPT
done

$IPCMD -A PREROUTING -t mangle -p tcp --dport 80 -j TOS --set-tos 16
$IPCMD -A PREROUTING -t mangle -p tcp --dport 443 -j TOS --set-tos 16
$IPCMD -A PREROUTING -t mangle -p tcp --dport 53 -j TOS --set-tos 8
$IPCMD -A PREROUTING -t mangle -p udp --dport 53 -j TOS --set-tos 16


## List rules
echo "## Check All Rules"
$IPCMD -S

dump "Iptalbes was applied."
if [ -n "$DEBUG_ONLY" ] ; then
    if [ -z "$DEBUG_SEC" ] ; then
        DEBUG_SEC=60;
    fi
    dump "Iptalbes Debug mode enable will reset after ${DEBUG_SEC}secs... Press ctrl+c to cancel reset."
    sleep $DEBUG_SEC;
    dump "Iptalbes was reset."
    initialize
fi
exit;
